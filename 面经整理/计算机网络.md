- [HTTP](#http)
  * [1、HTTP版本](#1-http--)
  * [2、常见状态码](#2------)
  * [3、请求方法的场景和区别](#3-----------)
  * [4、访问某个网站的流程，用到什么协议](#4-----------------)
  * [5、http的请求头和boby用什么来区分。](#5-http-----boby-------)
  * [6、http和https的区别](#6-http-https---)
  * [7、session、cookie、token的区别](#7-session-cookie-token---)
- [HTTPS](#https)
  * [1、为什么要有https](#1------https)
  * [2、对称加密与非对称加密](#2-----------)
  * [3、SSL的握手过程](#3-ssl-----)
  * [4、为什么需要证书](#4--------)
  * [5、使用https还会被抓包吗？](#5---https-------)
  * [6、数字签名、数字证书](#6----------)
- [传输层](#---)
  * [1、TCP与UDP的区别](#1-tcp-udp---)
  * [2、TCP三次握手和四次挥手，TCP为什么要三次握手和四次挥手，TCP三次握手和四次挥手的详细流程](#2-tcp----------tcp--------------tcp--------------)
  * [3、TCP TimeWait、CloseWait是什么](#3-tcp-timewait-closewait---)
  * [4、如果出现大量TimeWait或者CloseWait，怎么做，怎么分析](#4-------timewait--closewait---------)
  * [5、TCP的拥塞控制和流量控制](#5-tcp----------)
  * [6、TCP粘包如何处理](#6-tcp------)
  * [7、TCP滑动窗口的作用](#7-tcp-------)
  * [8、TCP、UDP的使用场景](#8-tcp-udp-----)
  * [9、UDP如何实现可靠传输](#9-udp--------)
  * [10、TCP滑动窗口糊涂综合征](#10-tcp---------)

# HTTP

## 1、HTTP版本

- http1.0
- http 1.1
  - 支持长连接
  - 流水线pipeline：一个请求阻塞了，就要等
  - host字段
  - chunked编码：发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
  - 缓存
- http 2.0
  - 多路复用：连接共享，一个连接上可以有多个request，通过request_id区分（流通道，）
  - 二进制分帧：方便健壮
  - 首部压缩：压缩header，两端维护了索引表，相同的header只需要发送索引值
  - 服务端推送：提前推送用户将要请求的资源

## 2、常见状态码

- 200：成功
- 301、302：永久重定向、临时重定向
- 403：鉴权失败
- 404：找不到
- 500：服务器内部错误
- 502：上游服务器无法访问
- 504：上游服务器处理超时

## 3、请求方法的场景和区别

- GET
  - 获取资源
  - 幂等，可以缓存
  - 参数在url里
- POST:
  - 提交资源
  - 非幂等，不缓存（除非修改浏览器设置）
  - 参数在body里
- DELETE
  - 删除资源

## 4、访问某个网站的流程，用到什么协议

- DNS，将HOST转换为IP
  - 浏览器缓存，本地Host文件，本地DNS服务器，运营商DNS服务器。。。
- IP，IP路由，拿到目的地址，拿到网关IP
- ARP，将IP转换为MAC地址，找到网关，出去
- TCP/UDP，建立TCP/UDP连接，端到端，某个进程到某个进程
- HTTP，建立HTTP连接
- Nginx网关反向代理到后端集群，得到数据，返回给下游
- 浏览器拿到数据解析，渲染，呈现

## 5、http的请求头和boby用什么来区分。

请求头每行\r\n结尾，请求头和请求体之间有一个空行。

## 6、http和https的区别

- https是http+ssl/tls，建立http连接的时候，要进行ssl握手，端口一般是443

## 7、session、cookie、token的区别

- session
  - **保存在服务器中**，**记录和维护客户端的状态，**可以用redis做共享，相当于“**客户明细表”**
  - SessionID可以用Cookie保存，如果禁用了Cookie，可以把SessionID放在Query中
- cookie
  - **保存在客户端浏览器中**，服务器发给客户端的“**通行证**”，客户端请求服务器时会携带Cookie一起提交
- token
  - **无状态**，用户信息加密放到token中，服务器收到token解密就知道是哪个用户

# HTTPS

## 1、为什么要有https

- 机密性：通过混合加密，保证了机密性
- 完整性：摘要算法实现了完整性
- 身份认证：将服务器公钥放在数字证书中，解决了冒充风险

## 2、对称加密与非对称加密

- 对称加密指加密和解密使用同一个密钥，加密解密速度快
- 非对称加密一般是用公钥加密，私钥解密，加密解密速度慢，适合少量数据

## 3、SSL的握手过程

1. 客户端发送协议版本号，客户端生成的随机数，以及支持的加密方法；
1. 服务端确认双方使用的加密方法，并给出数字证书和服务端生成的随机数；
1. 客户端确认数字证书有效（通过CA的公钥解密数字证书拿到服务端的公钥），然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，发给服务端；
1. 服务端使用自己的私钥，获取客户端法发来的随机数；
1. 客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成“对话密钥”，用来解密后续的整个通话过程；

- **生成对话密钥一共需要三个随机数**
- **握手之后的通信使用“对话密钥”进行对称加密**
- **服务器公钥放在服务器的数字证书中**
- **session可以复用，下次重连提供session id，就可以重新使用对话密钥**

## 4、为什么需要证书

防止“**中间人**”攻击（在传输过程中截获和篡改数据），确认会话双方的身份

## 5、使用https还会被抓包吗？

可以抓包，但看不到明文

## 6、数字签名、数字证书

- 数字签名：签名场景，私钥加密，公钥解密，不可抵赖；
- 数字证书：CA机构用自己的私钥对证书申请者的公钥进行认证（用户使用CA的公钥就能解密CA证书，拿到服务端的公钥）----->第三方机构确认服务端的公钥有效------>”公钥的数字签名”

# 传输层

## 1、TCP与UDP的区别

- TCP：面向连接的、可靠的字节流协议
- UDP：无连接的、不可靠的数据报协议

## 2、TCP三次握手和四次挥手，TCP为什么要三次握手和四次挥手，TCP三次握手和四次挥手的详细流程

- 三次握手，站在客户端连接服务端的角度
  - 第一次，客户端发送SYN请求（SYN=1），seq number= x
  - 第二次，服务端收到后，发送SYN-ACK确认（SYN=1,ACK=1），ack number = x + 1, seq number = y
  - 第三次，客户端收到后，会确认ack number是否合法，发送ACK确认（ACK=1），ack number = y + 1， seq number = x + 1，同时认为连接建立成功，服务端收到后，先确认ack number是否合法，如果合法，认为连接建立成功；
  - 至此回答为什么需要三次握手，原因是通信双方发出去的seq number都需要得到对方的ack number进行确认，这样才能保证可靠，这种情况下最少需要三次握手；如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，**等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接**。长此以往， 这样的连接越来越多，就会造成服务器开销的浪费。
- 四次挥手，站在客户端主动关闭连接的角度
  - 第一次，客户端发起关闭连接请求FIN，进入FIN_WAIT1状态
  - 第二次，服务端收到后会回复ACK，同时继续发送未发完数据，然后进入CLOSE_WAIT的状态，客户端收到ACK后，进入FIN_WAIT2状态
  - 第三次，服务端发送FIN，然后进入LAST_ACK状态
  - 第四次，客户端收到FIN，回复ACK，进入TIME_WAIT状态，服务端收到后，关闭连接
  - 至此回答为什么需要四次挥手，原因是被动关闭连接的一方有可能正在发数据，而且双方都需要确认发出去的FIN是否有ACK，就是四次

## 3、TCP TimeWait、CloseWait是什么

- TimeWait状态作用
  - **可靠的中止TCP连接**（假设被动关闭一方的FIN请求因为网络问题没有收到ACK，发生TCP重传，这时候有TimeWait状态存在，就能让对端正常关闭连接，释放资源）
  - **保证让迟来的TCP报文有足够的时间被识别和丢弃**（假设不存在TimeWait状态，这时候建立了一个新的连接，假设旧的连接的报文因为网络问题迟到了，这个时候就出现了不应该不符合预期的行为）
- CloseWait状态
  - 被动关闭连接一方在响应FIN后，进入CLOSE_WAIT状态，这时已经无法从对端读到数据了，但有可能需要把正在发送的数据发完，然后发送FIN进入LAST_ACK状态

## 4、如果出现大量TimeWait或者CloseWait，怎么做，怎么分析

- TimeWait
  - keeplive
  - 快速回收
- CloseWait
  - 根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，连接进入CLOSE_WAIT状态。但如果服务器端不执行socket的close()操作，状态就不能由CLOSE_WAIT迁移到LAST_ACK，然后就会占用TCP连接资源。理论上来说如果客户端发送了FIN，正常情况下服务端把数据发完以后就可以调用close或者shutdown，因为从客户端已经读不到应用层数据了。

## 5、TCP的拥塞控制和流量控制

- 流量控制
  - 控制发送方的发送速度，防止接收方来不及接收导致分组丢失，具体采用滑动窗口的方式实现
- 拥塞控制
  - 慢启动
  - 拥塞避免
  - 拥塞发生
  - 快速恢复

## 6、TCP粘包如何处理

- 原因：TCP是字节流协议，意味着TCP传输的数据没有边界，所以有可能出现两个包粘在一起的情况
- 解决
  - 发送定长包
  - 包头加上包体长度
  - 包之间设置边界，如\r\n

## 7、TCP滑动窗口的作用

- 可靠性：保证数据准确（按序、完整、未出错）到达目的地，如果未到达或数据出错，能够发现并重传。
- 流量控制：管理发送端的数据发送速率，以使接收设备不致于过载。

## 8、TCP、UDP的使用场景

- TCP：FTP、SSH、HTTP、SMTP、TELNET，对准确性要求高的场景
- UDP：DNS、TFTP、SNMP、NFS，对实时性要求高的场景

## 9、UDP如何实现可靠传输

- 应答确认
- 流量控制
- 拥塞控制
- 超时重传
- 握手
- 数据校验

## 10、TCP滑动窗口糊涂综合征

- 小包问题
  - 发送端
    - 应用层生产数据特别慢
    - Nagle算法
  - 接收端
    - 应用层接收数据特别慢，导致对端发的慢了